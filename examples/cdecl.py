# -----------------------------------------------------------------
# pycparser: cdecl.py
#
# Example of the CDECL tool using pycparser. CDECL "explains" C type
# declarations in plain English.
#
# The AST generated by pycparser from the given declaration is traversed
# recursively to build the explanation. Note that the declaration must be a
# valid external declaration in C. As shown below, typedef can be optionally
# expanded.
#
# For example:
#
#   c_decl = 'typedef int Node; const Node* (*ar)[10];'
#
#   explain_c_declaration(c_decl)
#   => ar is a pointer to array[10] of pointer to const Node
#
# struct and typedef can be optionally expanded:
#
#   explain_c_declaration(c_decl, expand_typedef=True)
#   => ar is a pointer to array[10] of pointer to const int
#
#   c_decl = 'struct P {int x; int y;} p;'
#
#   explain_c_declaration(c_decl)
#   => p is a struct P
#
#   explain_c_declaration(c_decl, expand_struct=True)
#   => p is a struct P containing {x is a int, y is a int}
#
# Eli Bendersky [https://eli.thegreenplace.net/]
# License: BSD
# -----------------------------------------------------------------
import copy
from typing import Optional

from cparsing import c_ast, parse


def explain_c_declaration(c_decl: str, expand_struct: bool = False, expand_typedef: bool = False) -> str:
    """Create an explanation in English for a declaration in C.

    Parameters
    ----------
    c_decl: str
        The declaration in C to parse.
    expand_struct: bool, default=True
        Whether to spell out struct definitions recursively.
    expand_typedef: bool, default=True
        Whether to expand typedef'd types.

    Returns
    -------
    str
        A text explanation of the declaration.

    Notes
    -----
    The last external node of the string is used, to allow earlier typedefs for used types.
    """

    node = parse(c_decl, filename="<stdin>")

    if not isinstance(node, c_ast.File) or not isinstance(node.ext[-1], c_ast.Decl):
        return "Not a valid declaration"

    expanded = expand_struct_typedef(node.ext[-1], node, expand_struct=expand_struct, expand_typedef=expand_typedef)

    return _explain_decl_node(expanded)


def _explain_decl_node(decl_node: c_ast.Decl) -> str:
    """Receives a c_ast.Decl note and returns its explanation in English."""

    if decl_node.storage:
        storage = f'{" ".join(decl_node.storage)} '
    else:
        storage = ""

    return f"{decl_node.name} is a {storage}{_explain_type(decl_node.type)}"


def _explain_type(decl: Optional[c_ast.AST]) -> str:
    """Recursively explains a type decl node."""

    if isinstance(decl, c_ast.TypeDecl):
        quals = " ".join(decl.quals) + " " if decl.quals else ""
        return f"{quals}{_explain_type(decl.type)}"

    elif isinstance(decl, (c_ast.Typename, c_ast.Decl)):
        return _explain_type(decl.type)

    elif isinstance(decl, c_ast.IdType):
        return " ".join(decl.names)

    elif isinstance(decl, c_ast.PtrDecl):
        quals = " ".join(decl.quals) + " " if decl.quals else ""
        return f"{quals}pointer to {_explain_type(decl.type)}"

    elif isinstance(decl, c_ast.ArrayDecl):
        arr = "array"
        if decl.dim:
            arr += f"[{decl.dim.value}]"

        return f"{arr} of {_explain_type(decl.type)}"

    elif isinstance(decl, c_ast.FuncDecl):
        if decl.args:
            args = ", ".join(_explain_type(param) for param in decl.args.params)
        else:
            args = ""

        return f"function({args}) returning {_explain_type(decl.type)}"

    elif isinstance(decl, c_ast.Struct):
        if decl.decls is not None:
            members = ", ".join(_explain_decl_node(mem_decl) for mem_decl in decl.decls)
        else:
            members = ""

        if members:
            containing = f"containing {{{members}}}"
        else:
            containing = ""

        return f'struct{(f" {decl.name}" if decl.name else "")} {containing}'

    else:
        return ""


def expand_struct_typedef(
    cdecl: c_ast.Decl,
    file_ast: c_ast.File,
    expand_struct: bool = False,
    expand_typedef: bool = False,
) -> c_ast.Decl:
    """Expand struct & typedef and return a new expanded node."""

    decl_copy = copy.deepcopy(cdecl)
    _expand_in_place(decl_copy, file_ast, expand_struct, expand_typedef)
    return decl_copy


def _expand_in_place(decl, file_ast: c_ast.File, expand_struct: bool = False, expand_typedef: bool = False):
    """Recursively expand struct & typedef in place.

    Raises
    ------
    RuntimeError
        If an undeclared struct or typedef is used.
    """

    if isinstance(decl, (c_ast.Decl, c_ast.TypeDecl, c_ast.PtrDecl, c_ast.ArrayDecl)):
        decl.type = _expand_in_place(decl.type, file_ast, expand_struct, expand_typedef)

    elif isinstance(decl, c_ast.Struct):
        if not decl.decls:
            struct = _find_struct(decl.name, file_ast)
            if not struct:
                msg = f"using undeclared struct {decl.name}"
                raise RuntimeError(msg)
            decl.decls = struct.decls
        assert decl.decls is not None

        decl.decls = [_expand_in_place(mem_decl, file_ast, expand_struct, expand_typedef) for mem_decl in decl.decls]

        if not expand_struct:
            decl.decls = []

    elif isinstance(decl, c_ast.IdType) and decl.names[0] not in ("int", "char"):
        typedef = _find_typedef(decl.names[0], file_ast)
        if not typedef:
            msg = f"using undeclared type {decl.names[0]}"
            raise RuntimeError(msg)

        if expand_typedef:
            return typedef.type

    return decl


def _find_struct(name: str, file_ast: c_ast.File) -> Optional[c_ast.Struct]:
    """Find the declared struct object with the given struct name in the given AST."""

    for node in file_ast.ext:
        if isinstance(node, c_ast.Decl) and isinstance(node.type, c_ast.Struct) and node.type.name == name:
            return node.type
    return None


def _find_typedef(name: str, file_ast: c_ast.File) -> Optional[c_ast.Typedef]:
    """Find the declared typedef object with the given type name in the given AST."""

    for node in file_ast.ext:
        if isinstance(node, c_ast.Typedef) and node.name == name:
            return node
    return None


def main() -> None:
    import argparse

    argparser = argparse.ArgumentParser()
    argparser.add_argument("c_decl", default="char *(*(**foo[][8])())[];")
    args = argparser.parse_args()
    c_decl: str = args.c_decl
    print(f"Explaining the declaration: {c_decl}\n")
    print(explain_c_declaration(c_decl))
    print()


if __name__ == "__main__":
    raise SystemExit(main())
